//
// Copyright (c) 2018,2019 Contributors to the Eclipse Foundation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

[[concurrencyspec]]
== MicroProfile Concurrency Specification

=== Introduction

MicroProfile Concurrency introduces APIs for propagating contexts across units of work that are thread-agnostic. It makes it possible to propagate context that was traditionally associated to the current thread across various types of units of work such as `CompletionStage`, `CompletableFuture`, `Function`, `Runnable` regardless of which particular thread ends up executing them.

=== Motivation

When using a reactive model, execution is cut into small units of work that are chained together to assemble a reactive pipeline. The context under which each unit of work executes is often unpredictable and depends on the particular reactive engine used. Some units might run with the context of a thread that awaits completion, or the context of a previous unit that completed and triggered the dependent unit, or with no/undefined context at all. Existing solutions for transferring thread context, such as the EE Concurrency Utilities `ContextService`, are tied to a specific asynchrony model, promotes usage of thread pools, is difficult to use and require a lot of boilerplate code. This specification makes it possible for thread context propagation to easily be done in a type-safe way, keeping boilerplate code to a minimum, as well as allowing for thread context propagation to be done automatically for many types of reactive models.

We distinguish two main use-cases for propagating contexts to reactive pipelines:

    - Splitting units of work into a sequential pipeline where each unit will be executed after the other. Turning an existing blocking request into an async request would produce such pipelines.

    - Fanning out units of work to be executed in parallel on a managed thread pool. Launching an asynchronous job from a request without waiting for its termination would produce such pipelines.

Goals

    - Pluggable context propagation to the most common unit of work types.

    - Mechanism for thread context propagation to `CompletableFuture` and `CompletionStage` units of work that reduces the need for boilerplate code.

    - Full compatibility with EE Concurrency spec, such that proposed interfaces can seamlessly work alongside EE Concurrency, without depending on it.

=== Solution

This specification introduces two interfaces that contain methods that can work alongside EE Concurrency, if available.

The interface, `org.eclipse.microprofile.concurrent.ManagedExecutor`, provides methods for obtaining managed instances of `CompletableFuture` which are backed by the managed executor as the default asynchronous execution facility and the default mechanism of defining thread context propagation. Similar to EE Concurrencyâ€™s `ManagedExecutorService`, the MicroProfile `ManagedExecutor` also implements the Java SE `java.util.concurrent.ExecutorService` interface, using managed threads when asynchronous invocation is required. It is possible for a single implementation to be capable of simultaneously implementing both `ManagedExecutor` and `ManagedExecutorService` interfaces.

A second interface, `org.eclipse.microprofile.concurrent.ThreadContext`, provides methods for individually contextualizing units of work such as `CompletionStage`, `CompletionFuture`, `Runnable`, `Function`, `Supplier` and more, without tying them to a particular thread execution model. This gives the user finer-grained control over the capture and propagation of thread context by remaining thread execution agnostic. It is possible for a single implementation to be capable of simultaneously implementing both `ThreadContext` and `ContextService` interfaces.

=== Builders

Instances of `ManagedExecutor` and `ThreadContext` can be constructed via builders with fluent API, for example,

[source, java]
----
    ManagedExecutor executor = ManagedExecutor.builder()
        .propagated(ThreadContext.APPLICATION)
        .cleared(ThreadContext.ALL_REMAINING)
        .maxAsync(5)
        .build();

    ThreadContext threadContext = ThreadContext.builder()
        .propagated(ThreadContext.APPLICATION, ThreadContext.CDI)
        .unchanged()
        .cleared(ThreadContext.ALL_REMAINING)
        .build();
----

Applications should shut down instances of `ManagedExecutor` that they build after they are no longer needed. The shutdown request serves as a signal notifying the container that resources can be safely cleaned up.

=== Injection of Configured Instances

The `@ManagedExecutorConfig` and `@ThreadContextConfig` annotations provide the ability to configure the injection points with desired capabilities.
With just the config annotation in place, every injection point is assigned a new instance.

[source, java]
----
    @Inject 
    @ManagedExecutorConfig(maxAsync = 5, propagated = ThreadContext.SECURITY, cleared = ThreadContext.ALL_REMAINING)
    ManagedExecutor configuredExecutor;
    ...
    CompletableFuture<Long> stage = configuredExecutor
        .newIncompleteFuture()
        .thenApply(function)
        .thenAccept(consumer);
    stage.completeAsync(supplier);
----

Or similarly:

[source, java]
----
    @Inject 
    @ThreadContextConfig(propagated = ThreadContext.SECURITY, unchanged = {}, cleared = ThreadContext.ALL_REMAINING)
    ThreadContext threadContext;
    ...
    threadContext.withContextCapture(unmanagedCompletionStage)
        .thenApply(function)
        .thenAccept(consumer);
----

=== Sharing Configured Instances

Configured instances of `ManagedExecutor` and `ThreadContext` are shared based on their unique name, which is assigned by the CDI qualifier, `@NamedInstance`.
When one injection point is annotated with both a configuration and a `@NamedInstance` qualifier, the application can inject the same instance elsewhere by annotating other injection points with just the matching qualifier.
In the example below, the `executor1` injection point defines a configuration and a name `myExec` for a configured `ManagerExecutor` instance.
The other injection points, `executor2` and `executor3`, share the same `ManagedExecutor` instance by using the `@NamedInstance` qualifier with the name `myExec`.

[source, java]
----
    @Inject
    @NamedInstance("myExec")
    @ManagedExecutorConfig(propagated = { ThreadContext.SECURITY, ThreadContext.APPLICATION },
                           cleared = ThreadContext.ALL_REMAINING)
    ManagedExecutor executor1;
    ... // in some other bean
    @Inject
    void setCompletableFuture(@NamedInstance("myExec") ManagedExecutor executor2) {
        completableFuture = executor2.newIncompleteFuture();
    }
    ... // in yet another bean
    @Inject
    @NamedInstance("myExec")
    ManagedExecutor executor3;
----

=== Integration with MicroProfile Config

This specification defines a convention for defining properties in MicroProfile Config that override configuration attributes of `ManagedExecutor` and `ThreadContext` instances that are produced by the container. The convention for the property name is the fully qualified class name of the injection point, combined with the injection point field name or method name with parameter position, annotation name, and annotation attribute, with the `/` character as delimiter.

The following example shows one injection point for `ManagedExecutor`, which is the first parameter of the `setCompletableFuture` method, and another injection point for `ThreadContext`, which is the `appContext` field.

[source, java]
----
package org.eclipse.microprofile.example;

import org.eclipse.microprofile.concurrent.ManagedExecutor;
import org.eclipse.microprofile.concurrent.ThreadContext;
import org.eclipse.microprofile.concurrent.ThreadContextConfig;
import java.util.concurrent.CompletableFuture;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

@ApplicationScoped
public class ExampleBean {
    CompletableFuture<Long> completableFuture;

    @Inject
    void setCompletableFuture(ManagedExecutor exec) {
        completableFuture = exec.newIncompleteFuture();
    }

    @Inject @ThreadContextConfig(propagated = ThreadContext.APPLICATION,
                                 cleared = ThreadContext.TRANSACTION,
                                 unchanged = ThreadContext.ALL_REMAINING)
    ThreadContext appContext;
}
----

The following MicroProfile config properties could be used to override specific configuration attributes of these instances,

[source, text]
----
org.eclipse.microprofile.example.ExampleBean/setCompletableFuture/1/ManagedExecutorConfig/maxAsync=5
org.eclipse.microprofile.example.ExampleBean/setCompletableFuture/1/ManagedExecutorConfig/maxQueued=20
org.eclipse.microprofile.example.ExampleBean/appContext/ThreadContextConfig/cleared=Security,Transaction
----

